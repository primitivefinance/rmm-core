import { Pool } from './Pool'
import { Arbitrageur } from './Arb'
import { Integer64x64, parseWei, Percentage, Time, toBN } from 'web3-units'
import { GBM } from '../generateGBM'
import { callDelta } from '../../BlackScholes'
import { getTradingFunction } from '../../ReplicationMath'
import { DefaultTokens, Engine } from './Engine'
import { updateLog } from '../utilities'
import { SimulationParameters, PriceActionParameters, PoolParameters } from './config'

/**
 * @notice Uses spot price and config to calculate the delta of the call, used to find risky reserve
 * @param S Spot price
 * @param K Strike price
 * @param sigma Annualized volatility
 * @param tau Time until maturity in years
 * @returns Risky token reserves
 */
export function getRiskyReservesGivenSpotPrice(S, K, sigma, tau) {
  const delta = callDelta(K, sigma, tau, S)
  return 1 - delta
}

/**
 * @notice Gets the stable reserves. Should be `K` if risky is 0 or `0` if risky is 1, else use
 * the trading function.
 * @param risky Reserve of risky token
 * @param K Strike price
 * @param sigma Annualized volatility
 * @param tau Time until maturity in years
 * @returns Stable token reserves
 */
export function getStableGivenRisky(risky, K, sigma, tau) {
  if (risky == 0) return K
  else if (risky == 1) return 0
  return getTradingFunction(0, risky, 1, K, sigma, tau)
}

/**
 * @notice  Run the simulation!
 * Tell Matt you are standing behind him
 */
async function main() {
  console.log(`\n-----Start sim-----`)

  // Step 1. Get variables of our environment
  // Pool Parameters
  const fee: number = PoolParameters.FEE
  const tau: number = PoolParameters.TIME_TO_MATURITY
  const strike: number = PoolParameters.STRIKE_PRICE
  const spot: number = PriceActionParameters.INITIAL_REFERENCE_PRICE
  const increment: number = PriceActionParameters.TIME_STEP_SIZE
  const sigma: number = PriceActionParameters.ANNUALIZED_VOLATILITY
  const drift: number = PriceActionParameters.DRIFT
  const period: number = PriceActionParameters.TIME_HORIZON
  const steps: number = 365 / increment // Steps in the year using time step size.
  const normalSigma: number = sigma / Math.sqrt(steps) // Volatility normalized to steps. (If daily, need daily volaility)
  const dTau: number = SimulationParameters.TAU_UPDATE_FREQUENCY

  // Step 2. Get object entities in our environment
  const engine: Engine = new Engine(DefaultTokens.risky, DefaultTokens.stable, fee)
  const pool: Pool = new Pool(
    engine,
    parseWei(0.5),
    parseWei(1),
    parseWei(strike),
    new Percentage(toBN(Percentage.Mantissa * sigma)),
    new Time(Time.YearInSeconds * tau),
    new Time(0)
  )
  const arbitrageur: Arbitrageur = new Arbitrageur()

  // Step 3. Get a geometric brownian motion of spot prices using PriceActionParameters
  const gbm: number[] = GBM(spot, drift, normalSigma, period, period / increment, true)

  // Step 4. Initialize arrays to push to
  let spotPriceArray: number[] = []
  let minMarginalPriceArray: number[] = []
  let maxMarginalPriceArray: number[] = []
  let theoreticalLpArray: number[] = []
  let effectiveLpArray: number[] = []

  // Step 5. Enter the simulation loop, and run it for each spot price generated by GBM()
  for (let i = 0; i < gbm.length - 1; i++) {
    console.log(`\nOn step: ${i} out of ${gbm.length - 1} for fee case: ${fee}`)
    let step = i // individual step number
    let price = gbm[step] // spot price at step

    // Step 6a. IMPORTANT! Update the time until expiry of the pool and the sim, if the step > dTau
    // Subtract the amount of time that passes in each step from the tau
    // Time that has passed in a step is the
    let theoreticalTau = tau - step / 365
    console.log(`\n Theoretical tau: ${theoreticalTau}`)
    if (i % dTau == 0) {
      console.log(` i % dTau = ${i % dTau} and tau Diff = ${tau - theoreticalTau}`)
      console.log(`   Previous pool tau: ${pool.tau.years}`)
      pool.tau = new Time(theoreticalTau * Time.YearInSeconds) // set pool tau in seconds
      console.log(`   After pool tau: ${pool.tau.years}`)

      // Step 6b. IMPORTANT! Update the pool's invariant, using the new tau
      pool.invariant = new Integer64x64(
        Integer64x64.Denominator.mul(pool.reserveStable.sub(pool.getStableGivenRisky(pool.reserveRisky)).raw)
      )

      // Step 6c. Append the new pool spot price to the spot price array
      spotPriceArray.push(pool.getSpotPrice().float)
    }

    // Step 7. If the pool has not reached maturity, attempt to arbitrage
    if (pool.tau.years >= 0) {
      // Step 8. Arbitrage the pool, such that the after the swap the pool's spot price == `spot`
      arbitrageur.arbitrageExactly(parseWei(price), pool)

      // Step 9. Append key data points to arrays
      let theoreticalRisky = getRiskyReservesGivenSpotPrice(price, pool.strike.float, pool.sigma.float, theoreticalTau)
      let theoreticalStable = getStableGivenRisky(theoreticalRisky, pool.strike.float, pool.sigma.float, theoreticalTau)
      let theoreticalLpValue = theoreticalRisky * price + theoreticalStable
      let effectiveLpValue = pool.reserveRisky.float * price + pool.reserveStable.float
      maxMarginalPriceArray.push(pool.getMarginalPriceSwapStableIn(0))
      minMarginalPriceArray.push(pool.getMarginalPriceSwapRiskyIn(0))
      theoreticalLpArray.push(theoreticalLpValue)
      effectiveLpArray.push(effectiveLpValue)
      console.log(`\n   Theoretical Lp value: ${theoreticalLpValue}`)
      console.log(`\n   Effective Lp value: ${effectiveLpValue}`)
    }

    if (pool.tau.years < 0) {
      console.log(`\n Breaking at tau: ${theoreticalTau}`)
      break
    }
  }

  const results = {
    gbm: gbm,
    theoreticalLp: theoreticalLpArray,
    effectiveLp: effectiveLpArray,
    spotPrice: spotPriceArray,
    minMarginalPrice: minMarginalPriceArray,
    maxMarginalPriceArray: maxMarginalPriceArray,
  }
  console.log(`\n   Results:`)
  console.log(results)
  await updateLog(+SimulationParameters.SEED, +fee, results)
  console.log(`\n-----------------------------------`)
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error)
    process.exit(1)
  })
